# For the reference here are some automatic variables defined by make.
# There are also their D/F variants e.g. $(<D) - check the manual.
#
# $@ - file name of the target of the rule
# $% - target member name when the target is archive member
# $< - the name of the first dependency
# $? - the names of all dependencies that are newer then the target
# $^ - the names of all dependencies

# Directory specific flags.  You just define in Rules.mk say
# INCLUDES_$(d) := ....
# and this will get expanded properly during compilation (see e.g. COMPILE.c)
# Of course you can still use the target specific variables if you want
# to have special setting for just one target and not the whole
# directory.  See below for definition of @RD variable.
DIR_INCLUDES = $(addprefix -I,$(INCLUDES_$(@RD)))
DIR_CPPFLAGS = $(CPPFLAGS_$(@RD))
DIR_CFLAGS = $(CFLAGS_$(@RD))
DIR_CXXFLAGS = $(CXXFLAGS_$(@RD))

OPT_FLAGS = -O3 -ftree-vectorize -march=native -mtune=native -msse3 -ffast-math
release_CFLAGS = $(OPT_FLAGS)
release_CXXFLAGS = $(OPT_FLAGS)
release_CPPFLAGS = -DRELEASE
release_LDFLAGS =

debug_CFLAGS = -ggdb
debug_CXXFLAGS = -ggdb
debug_CPPFLAGS = -DDEBUG
debug_LDFLAGS = -ggdb

prof_CFLAGS = -ggdb -pg $(OPT_FLAGS)
prof_CXXFLAGS = -ggdb -pg $(OPT_FLAGS)
prof_CPPFLAGS = -DPROFILE
prof_LDFLAGS = -ggdb -pg

CFLAGS = -W -Wall $(DIR_CFLAGS) $($(BUILD_MODE)_CFLAGS)
CXXFLAGS = -W -Wall $(DIR_CXXFLAGS) $($(BUILD_MODE)_CXXFLAGS)

# List of includes that all (or at least majority) needs
INCLUDES :=

# Here's an example of settings for preprocessor.  -MMD is to
# automatically build dependency files as a side effect of compilation.
# This has some drawbacks (e.g. when you move/rename a file) but it is
# good enough for me.  You can improve this by using a special script
# that builds the dependency files (one can find examples on the web).
# Note that I'm adding DIR_INCLUDES before INCLUDES so that they have
# precedence.
CPPFLAGS = -MP -MMD -D_REENTRANT -D_POSIX_C_SOURCE=200112L -D__EXTENSIONS__ \
	   $(DIR_CPPFLAGS) $(DIR_INCLUDES) -DBUILD_MODE="$(BUILD_MODE)" $($(BUILD_MODE)_CPPFLAGS) $(addprefix -I,$(INCLUDES))

# Linker flags.  The values below will use what you've specified for
# particular target or directory but if you have some flags or libraries
# that should be used for all targets/directories just append them at end.
LDFLAGS = $(LDFLAGS_$(@)) $(addprefix -L,$(LIBDIRS_$(@RD))) $($(BUILD_MODE)_LDFLAGS)

# List of libraries that all targets need (either with specific command
# generated by this makefile system or for which make has built in rules
# since LDLIBS is a variable that implicit make rules are using).
# LDLIBS can be either simple or recursive, but simpler version is
# suggested :).
LDLIBS :=

############# This is the end of generic flags #############

# Now we suck in configuration ...
include $(MK)/config.mk
# ... host and build specific settings ...
ifneq ($(wildcard $(MK)/config-$(BUILD_ARCH)_$(HOST_ARCH).mk),)
  include $(MK)/config-$(BUILD_ARCH)_$(HOST_ARCH).mk
else
  include $(MK)/config-default.mk
endif

# ... and here's a good place to translate some of these settings into
# compilation flags/variables.  As an example a preprocessor macro for
# target endianess
ifeq ($(ENDIAN),big)
  CPPFLAGS += -DBIG_ENDIAN
else
  CPPFLAGS += -DLITTLE_ENDIAN
endif

# Use host/build specific config files to override default extension
# for shared libraries 
SOEXT := $(or $(SOEXT),so)

######### A more advanced part - if you change anything below    ######
######### you should have at least vague idea how this works :D  ######

# I define these for convenience - you can use them in your command for
# updating the target.  Since I'm using fake file dependency to make
# sure the OBJDIR exists I filter it out here.  Mnemonic for these
# ? ^ versions is Real (that is not fake :))
DEP_OBJS = $(filter %.o, $^)
DEP_ARCH = $(filter %.a, $^)
DEP_LIBS = $(addprefix -L,$(dir $(filter %.$(SOEXT), $^))) $(patsubst lib%.$(SOEXT),-l%,$(notdir $(filter %.$(SOEXT), $^)))
#?R = $(filter-out $(OBJPATS),$?)
#^R = $(filter-out $(OBJPATS),$^)
?R = $?
^R = $^

# Targets that match this pattern (make pattern) will use rules defined
# in:
# - def_rules.mk included below (explicit or via `skeleton' macro)
# - built in make rules
# Other targets will have to use _DEPS (and so on) variables which are
# saved in `save_vars' and used in `tgt_rule' (see below).
AUTO_TGTS := %.o

# Where to put the compiled objects.  You can e.g. make it different
# depending on the target platform (e.g. for cross-compilation a good
# choice would be OBJDIR := obj/$(HOST_ARCH)) or debugging being on/off.
OBJDIR = $(HOST_ARCH)
OBJPATHS = $(addprefix $(d)/$(OBJDIR)/,$(BUILDMODES))
OBJPATS = $(addprefix %/$(OBJDIR)/,$(BUILDMODES))

# This variable contains a list of subdirectories where to look for
# sources.  That is if you have some/dir/Rules.mk where you name object
# say client.o this object will be created in some/dir/$(OBJDIR)/ and
# corresponding source file will be searched in some/dir and in
# some/dir/{x,y,z,...} where "x y z ..." is value of this variable.
SRCS_VPATH := src

# Target "real directory" - this is used above already and is most
# reliable way to refer to "per directory flags".  In theory one could
# use automatic variable already defined by make "<D" but this will not
# work well when somebody uses SRCS_VPATH variable.  Make defines also
# "@D" but I'm not using it since I would have to strip OBJDIR anyway
# and the value below is just slightly modified definition of what @D
# is (I assume that since make is using patsubst rather than subst for
# definition of @D then this is just "better").
#@RD = $(patsubst %/$(OBJDIR)/,%,$(dir $@))
@RD = $(patsubst %/$(od)/,%,$(dir $@))

# These are commands that are used to update the target.  If you have
# a target that make handles with built in rules just add its pattern to
# the AUTO_TGTS below.  Otherwise you have to supply the command and you
# can either do it explicitly with _CMD variable or based on the
# target's suffix and corresponding MAKECMD variable.  For example %.a
# are # updated by MAKECMD.a (exemplary setting below).  If the target
# is not filtered out by AUTO_TGTS and there's neither _CMD nor suffix
# specific command to build the target DEFAULT_MAKECMD is used.  See
# above for the explanation of the R versions of ? and ^ variables.
MAKECMD.a = $(call echo_cmd,AR $@) $(AR) $(ARFLAGS) $@ $(?R) && $(RANLIB) $@
MAKECMD.$(SOEXT) = $(LINK.cc) $(DEP_OBJS) $(DEP_ARCH) $(DEP_LIBS) $(LIBS_$(@)) $(LDLIBS) -shared -o $@
DEFAULT_MAKECMD = $(LINK.cc) $(DEP_OBJS) $(DEP_ARCH) $(DEP_LIBS) $(LIBS_$(@)) $(LDLIBS) -o $@

########################################################################
# Below is a "Blood sugar sex^H^H^Hmake magik" :) - don't touch it
# unless you know what you are doing.
########################################################################

# This can be useful.  E.g. if you want to set INCLUDES_$(d) for given
# $(d) to the same value as includes for its parent directory plus some
# add ons then: INCLUDES_$(d) := $(INCLUDES_$(parent)) ...
parent = $(patsubst %/,%,$(dir $(d)))

define include_subdir_rules
dir_stack := $(d) $(dir_stack)
d := $(d)/$(1)
include $(MK)/header.mk
include $(addsuffix /Rules.mk,$$(d))
include $(MK)/footer.mk
d := $$(firstword $$(dir_stack))
dir_stack := $$(wordlist 2,$$(words $$(dir_stack)),$$(dir_stack))
endef

define save_vars
DEPS_$(1)/$(2) = $$($(2)_DEPS)
LIBS_$(1)/$(2) = $$($(2)_LIBS)
LDFLAGS_$(1)/$(2) = $$($(2)_LDFLAGS)
CMD_$(1)/$(2) = $$($(2)_CMD)
endef

define tgt_rule_info
t1 := $1
$$(info 1=$$(t1))
$$(info bmd=$$(bmd))
$$(info DEPS_$(1)=$$(DEPS_$(1)))
$$(info bmd_deps=$$(bmd_deps))
$$(info abs_deps=$$(abs_deps))
endef

mkoutdir_ = @mkdir -p $(dir $@)
mkoutdir = $(mkoutdir_$(wildcard $(dir $@)))

define tgt_rule
bmd := $$(lastword $$(subst /, ,$$(dir $1)))
bmd_deps := $$(filter $$(addprefix %/$$(bmd)/,$$(notdir $$(DEPS_$(1)))),$$(DEPS_$(1)))
abs_deps := $$(filter /%,$$(bmd_deps))
rel_deps := $$(filter-out /%,$$(DEPS_$(1)))
abs_deps += $$(addprefix $(dir $1),$$(rel_deps))
-include $$(addsuffix .d,$$(basename $$(abs_deps)))
$(1): BUILD_MODE := $$(bmd)
$(1): $$(abs_deps)
	$(value mkoutdir)
	$$(or $$(CMD_$(1)),$$(MAKECMD$$(suffix $$@)),$$(DEFAULT_MAKECMD))
endef

# subtree_tgts is now just a special case for more general get_subtree
# macro since $(call get_subtree,TARGETS,dir) has the same effect but
# I'm keeping it for backward compatibility
define subtree_tgts
$(TARGETS_$(1)) $(foreach sd,$(SUBDIRS_$(1)),$(call subtree_tgts,$(sd)))
endef

define get_subtree
$($(1)_$(2)) $(foreach sd,$(SUBDIRS_$(2)),$(call get_subtree,$(1),$(sd)))
endef

# Suck in the default rules
include $(MK)/def_rules.mk
